#PYTHON module for analyzing charge density waves and Bohr-Oppenheimer energy surfaces

import numpy as np
import matplotlib.pyplot as plt
import glob
from ase import Atoms
import re
import os
from math import gcd

#import yaiv.transformations as trs
import yaiv.utils as ut
import yaiv.experimental.utils as utx
import yaiv.experimental.cell_analyzer as cell
import yaiv.constants as cons


def read_dyn_file(file):
    """Read the .dyn# file generated by QE and outputs:
    q_point(alat), basis(alat), atomic_positions(alat), frequencies(cm-1), displacements(normalized) and alat.

    alat= in a.u.
    freq[n] and displacement[n] is the way to acces the data.
    return q_point, basis, positions, freqs, displacements, alat"""
    read_qpoint=True
    read_vec=False
    first_vec=True
    atom_types=[]
    freqs=[]
    dyn_out=open(file,'r')
    for line_n, line in enumerate(dyn_out):
        if line_n==2: # reads atom types and atoms number
            l=line.split()
            num_atoms=int(l[1])
            num_types=int(l[0])
            alat=float(l[3])
        if line_n>2 and line_n in range(7,7+num_types): #read atom types
            l=line.split()
            atom_types=atom_types+[l[1][1:]]
        if line_n>2 and line_n in range(7+num_types,7+num_types+num_atoms): # read positions
            l=line.split()
            l=[float(i) for i in l]
            pos=np.array(l)
            try:
                positions=np.vstack([positions,pos])
            except NameError:
                positions=pos
        if line_n in [4,5,6]:
            l=line.split()
            b=np.array([float(l[0]),float(l[1]),float(l[2])])
            try:
                basis_vec=np.vstack([basis_vec,b])
            except NameError:
                basis_vec=b
        if re.search('q =',line) and read_qpoint==True:
            l=line.split()
            q_point=np.array([float(l[3]),float(l[4]),float(l[5])])
            read_qpoint=False
        if read_vec==True and num<=num_atoms:
            l=line.split()
            X=complex(float(l[1]),float(l[2]))
            Y=complex(float(l[3]),float(l[4]))
            Z=complex(float(l[5]),float(l[6]))
            if num==1:
                v=np.array([X,Y,Z])
            else:
                v=np.vstack([v,np.array([X,Y,Z])])
            num=num+1 # counts the number of atoms
            if num>num_atoms:
                read_vec=False
                if first_vec==True:
                    vectors=[v]
                    first_vec=False
                else:
                    vectors=vectors+[v]
        if re.search('freq',line):
            l=line.split()
            f=float(l[7])
            freqs=np.append(freqs,f)
            read_vec=True
            num=1 # counter so that we read num_atoms vectors for each freq
    atoms=[]
    for p in positions:
        atoms=atoms+[atom_types[int(p[1])-1]]
    positions=[atoms,positions[:,2:]]
    vectors=np.array(vectors)
    return q_point,basis_vec,positions,freqs,vectors,alat

def __pol_matmul(a,b):
    """Dot product between two polarization vectors written as default QE output.
    Used as pol_matmul(vecs[1],vecs[4])"""
    dot=0
    for i in range(len(a)):
        part=np.dot(np.conj(a[i]),b[i])
        dot=dot+part
    return dot

def __qe_norm_factor2(QE_disp,masses):
    """Gets the normalization factor for each QE eigenvalue.
    With the QE dynamical matrix and QE normalized displacements the output of the sandwitch:
    vector.Dynamical.vector=N^2 freq^2  (freq in Ry)
    Where N^2 is given by this function using eig=QE_disp"""
    atoms=len(masses)
    N=0
    for i in range(atoms):
        N=N+masses[i]*(np.linalg.norm(QE_disp[i]))**2
    return N

def __find_dyn_file(q_cryst,results_ph_path):
    """Finds the QE.dyn* file that holds the q point you are looking for.
    q_cryst = q point you are interested in crystaline units
    results_ph_path = Folder where you ph.x output is stored.
    returns: qe_dyn_file
    """
    dyn1_file=glob.glob(results_ph_path+'/*dyn1')
    basis=read_dyn_file(dyn1_file[0])[1]
    K_vec=ut.K_basis(basis)

    output=None
    dyn_files=glob.glob(results_ph_path+'/*dyn*')
    for file in dyn_files:
        lines=open(file,'r')
        for line in lines:
            if re.search('q =',line):
                l=line.split()
                q=[float(l[i]) for i in range(3,6)]
                q_c=ut.cartesian2cryst(q,K_vec)
                deg=ut.__expand_star(q_c)
                for q in deg:
                    diff=q_cryst-q
                    if np.all(np.around(diff,decimals=4)==0):
                        output=file
    if output==None:
        print('ERROR: Point not found in dyn0 file (doesn\'t compute star)')
    return output

def read_dyn_file_q(file,q_cryst):
    """Read the .dyn# file generated by QE and outputs:
    q_point(alat), basis(alat), atomic_positions(alat), alat(a.u), QE_dynamical matrix, atomic_masses(Ry?).
    INPUT:
    file = dyn file you want to read.
    q_cryst = q point you are interested in crystaline units

    notice that:
    q_point = q point you have read in alat units (as QE prints it)
    QE_dynamical matrix is not the true dynamical matrix, instead is what QE print as the dynamical matrix.
    It is multiplied by sqrt(MiMj) where Mi and Mj are the masses of i and j atoms related by the matrix.
    You have to multiply by these masses each (3x3) submatrix in order to diagonalize and get freq^2 (Ry)
    as eigenvalues.

    return: q_point, basis, positions, alat, QE_dynamical_matrix, atom_mass"""
    read_dynmat=False
    first_vec=True
    atom_types=[]
    atom_mass=[]
    dyn_out=open(file,'r')
    for line_n, line in enumerate(dyn_out):
        if line_n==2: # reads atom types and atoms number
            l=line.split()
            num_atoms=int(l[1])
            num_types=int(l[0])
            alat=float(l[3])
        if line_n>2 and line_n in range(7,7+num_types): #read atom types
            l=line.split()
            atom_types=atom_types+[l[1][1:]]
            atom_mass=atom_mass+[float(l[3])]
        if line_n>2 and line_n in range(7+num_types,7+num_types+num_atoms): # read positions
            l=line.split()
            l=[float(i) for i in l]
            pos=np.array(l)
            try:
                positions=np.vstack([positions,pos])
            except NameError:
                positions=pos
        if line_n in [4,5,6]:
            l=line.split()
            b=np.array([float(l[0]),float(l[1]),float(l[2])])
            try:
                basis_vec=np.vstack([basis_vec,b])
            except NameError:
                basis_vec=b
        if re.search('q =',line):
            l=line.split()
            q_point=np.array([float(l[3]),float(l[4]),float(l[5])])
            q_c=ut.cartesian2cryst(q_point,ut.K_basis(basis_vec))
            deg=ut.__expand_star(q_c)
            for q in deg:
                diff=q-q_cryst
                if np.all(np.around(diff,decimals=4)==0):
                    dim=num_atoms*3
                    dyn_mat=np.zeros([dim,dim],dtype=complex)
                    read_dynmat=True
        if read_dynmat==True:
            #read dinamical matrix
            l=line.split()
            if len(l)==2: #block indices
                n=int(l[0])
                m=int(l[1])
                num=0
            elif len(l)==6: #matrix components
                X=complex(float(l[0]),float(l[1]))
                Y=complex(float(l[2]),float(l[3]))
                Z=complex(float(l[4]),float(l[5]))
                row=np.array([X,Y,Z])
                if num==0:
                    sub_mat=row
                    num=1
                else:
                    sub_mat=np.vstack([sub_mat,row])
                    num=num+1
                if num==3:
                    i=(n-1)*3
                    j=(m-1)*3
                    dyn_mat[i:i+3,j:j+3]=sub_mat
            if re.search('Dynamical',line) or re.search('Diagonalizing',line):
                break
    atoms=[]
    masses=[]
    for p in positions:
        atoms=atoms+[atom_types[int(p[1])-1]]
        masses=masses+[atom_mass[int(p[1])-1]]
    positions=[atoms,positions[:,2:]]
    return q_point,basis_vec,positions,alat,dyn_mat,masses

def __freq_disp_matdyn(dyn_mat,masses):
    """Given the dynamical matrix and masses in QE.dyn units it replicates QE output:
    frequencies (cm-1), displacements(normalized).

    return: freqs, displacements"""
    #build the real dinamical matrix mat
    dim=int(dyn_mat.shape[0]/3)
    mat=np.zeros([dim*3,dim*3],dtype=complex)
    for n in range(dim):
        for m in range(dim):
            i=3*n
            j=3*m
            mat[i:i+3,j:j+3]=dyn_mat[i:i+3,j:j+3]/np.sqrt(masses[n]*masses[m])
    eig,pol=np.linalg.eig(mat)

    #change freqcuencies to (cm-1) and to real
    eig=np.sqrt(eig)*cons.Ry2cm
    for i,v in enumerate(eig):
        if np.around(np.imag(v),decimals=10)==0:
            eig[i]=np.real(v)
        elif np.around(np.real(v),decimals=10)==0:
            eig[i]=-np.abs(np.imag(v))
        else:
            print('Frequency is neither real or imaginary')
            return 'Error: Frequency is neither real or imaginary'
    eig=np.real(eig)

    #go from polarization vectors to normalized displacements
    eigenvectors=np.array(pol)
    for c in range(len(eigenvectors)):
        for n in range(dim):
            i=3*n
            eigenvectors[i:i+3,c]=eigenvectors[i:i+3,c]/np.sqrt(masses[n])
        eigenvectors[:,c]=eigenvectors[:,c]/np.linalg.norm(eigenvectors[:,c])
    eigenvectors=eigenvectors.transpose()
    pol=pol.transpose()

    #order both displacements and freqs
    freqs=np.array(eig)
    disp=np.array(eigenvectors)
    pol_vec=np.array(pol)
    order=np.argsort(eig)
    for i,n in enumerate(order):
        freqs[i]=eig[n]
        disp[i]=eigenvectors[n]
        pol_vec[i]=pol[n]

    #write displacemnets in QE form:
    for d in disp:
        try:
            displacements=np.vstack([displacements,[d.reshape((dim,3))]])
        except NameError:
            displacements=[d.reshape((dim,3))]
    return freqs,displacements

def __benchmark_diago(dyn_file,thr_freq=3,thr_vec=4):
    """Given a QE.dyn file it benchmarks the output of QE agains the modules subroutines to read and
    diagonalize the dynamical matrix.
    thr_freq = Up to what decimal to check frequencies.
    thr_vec = Up to what decimal to check vectors.

    Notice that there is a Ry2cm-1 factor involved and that the eigenvectors are well defined up to a
    complex phase. This routine rotates each eigenvector to the same angle as QE in order to compare.

    WARNING = The benchmark will fail for any degenerate modes!!! Any linear combination can be a mode
    """
    print('Frequencies up to',thr_freq,'decimal')
    print('Vectors up to',thr_vec,'decimal')
    print('(Only ouputs when there is a mismatch)')
    print()
    #Read QE ouput directly
    q,basis,positions,qe_freqs,qe_vecs=read_dyn_file(dyn_file)[0:5]

    #Find q_cryst
    K_vec=ut.K_basis(basis)
    q_cryst=ut.cartesian2cryst(q,K_vec)

    #read the QE "dynamical matrix"
    tmp=dyn_file.split('/')
    path=''
    for word in tmp[:-1]:
        path=path+word+'/'
    tmp=__find_dyn_file(q_cryst,path)
    q,basis,positions,alat,dynmat,masses=read_dyn_file_q(tmp,q_cryst)

    #"diagonalize" the matrix to find displacements and frequencies:
    freqs,vecs=__freq_disp_matdyn(dynmat,masses)

    #check frequencies
    for i,f in enumerate(freqs):
        diff=freqs[i]-qe_freqs[i]
        if np.around(diff,decimals=thr_freq)!=0:
            print('freqs',freqs[i],qe_freqs[i],'dont past the test.')

    #check polarization vectors
    dim=vecs[0].shape[0]*vecs[0].shape[1]
    for i,vec in enumerate(vecs):
        #reshape
        v=np.reshape(vec,[1,dim])[0]
        qe=np.reshape(qe_vecs[i],[1,dim])[0]
        #find qe_angle
        for c,j in enumerate(qe):
            if np.around(j,decimals=2)!=0:
                angle_v=np.angle(v[c])
                angle_qe=np.angle(qe[c])
                phase=np.exp(1j*(angle_qe-angle_v))
                break
        #rotate my computed vector to align
        for j,elem in enumerate(v):
            v[j]=v[j]*phase
        #check the difference:
        diff1=np.around(v-qe,decimals=thr_vec)
        diff2=np.around(v+qe,decimals=thr_vec)
        if np.any(diff1!=0) and np.any(diff2!=0):
            print('pol vector',i+1,"not correct")
            print(np.around(v,decimals=thr_vec))
            print(np.around(qe,decimals=thr_vec))
    print('Test finished!')


def __benchmark_all(results_ph_path,thr_freq=3,thr_vec=3):
    """Iterates over all the QE.dyn files in order to benchmark them (look __benchmark_diago)
    thr_freq = Up to what decimal to check frequencies.
    thr_vec = Up to what decimal to check vectors.

    WARNING = The benchmark will fail for any degenerate modes!!! Any linear combination can be a mode
    """
    files=glob.glob(results_ph_path+'/*dyn*')
    for file in sorted(files)[1:]:
        print(file)
        __benchmark_diago(file,thr_freq,thr_vec)

def __generate_supercell(q_point,basis_vec,cryst_units=False):
    """Returns the supercell conmensurate with the q_point and the q_point in crystalline units:
    q_point: q point in 2pi/alat as printed by ph.dyn
    basis_vec: Real space basis vectors in alat as printed by ph.dyn
    cryst_units: Wether the input is in crystal units
    return: supercell, q_cryst"""
    if len(np.shape(q_point))==1:
        if cryst_units==False:
            q_cryst=ut.cartesian2cryst(q_point,ut.K_basis(basis_vec))
        else:
            q_cryst=q_point
        scell=np.abs(q_cryst)
        for i,num in enumerate(scell):
            if np.around(num,4)==0:
                scell[i]=1
        supercell=np.around(np.ones(3)/scell)
        supercell=supercell.astype(int)
    elif len(np.shape(q_point))==2:
        if cryst_units==False:
            q_cryst=ut.cartesian2cryst(q_point,ut.K_basis(basis_vec),list_of_vec=True)
        else:
            q_cryst=q_point
        scell=np.abs(q_cryst)
        supercell=np.ones(3).astype(int)
        for i,vec in enumerate(scell): #For all K-vectors
            for j,num in enumerate(vec): #For each component j of every vector(i)
                if np.around(num,4)==0:
                    scell[i,j]=1
            p_super=np.ones(3)/scell[i]  #Partial supercell for each vector
            p_super=np.around(p_super).astype(int)
            for j,num in enumerate(p_super): #Find conmensurate between supercell and p_super
                mcm=supercell[j]*p_super[j]/gcd(supercell[j],p_super[j])
                supercell[j]=mcm
    return supercell,q_cryst

def distort_phonon_old(q_cryst,freq,results_ph_path,dist=0,silent=False):
    """Distort the structure according to a given active phonon and get an ase.Atoms superstructure as output.

    In order to point that phonon you need:
    q_cryst = q point you are interested in crystaline units.
    freq = index of the frequenzy you are interested in.
    results_ph_path = Folder where you ph.x output is stored.
    dist = Amount of distortion in the desired direction.
    silent = No text output
    """
    #Find correct file to read
    dyn=__find_dyn_file(q_cryst,results_ph_path)

    #read the dyn file
    if silent==False:
        print('reading',dyn,'...')
    q,basis,atoms,alat,dynmat,atoms_mass=read_dyn_file_q(dyn,q_cryst)
    if silent==False:
        print('point q =',q)
    #Get frequencies and displacements:
    freqs,displacements=__freq_disp_matdyn(dynmat,atoms_mass)
    if silent==False:
        print('Frequency =',freqs[freq-1],'cm-1')
        print('Displacement vector =')
        print(np.around(displacements[freq-1],decimals=6))

    #generate original crystal
    #print(positions)
    atoms[1]=[ut.cartesian2cryst(p,basis) for p in atoms[1]] #change to cryst units
    Pcell=basis*alat*cons.au2ang
    primitive=Atoms(symbols=atoms[0],scaled_positions=atoms[1],cell=Pcell)

    #find conmensurate supercell
    supercell,q_cryst=__generate_supercell(q,basis)
    supercell=[np.int(np.around(s)) for s in supercell]
    if silent==False:
        print('Conmensurate supercell:',supercell)

    #GENERATE DISTORTED SUPERCELL
    #simbols and supercell
    symbols=np.prod(supercell)*atoms[0]
    scell=np.ones([3,3])
    for i in range(3):
        scell[i]=Pcell[i]*supercell[i]

    #displacement vector for the unit cell
    f=freqs[freq-1]
    vec=displacements[freq-1]*dist
    indices=supercell

    for i in range(indices[0]):
        for j in range(indices[1]):
            for k in range(indices[2]):
                new_pos=np.array(atoms[1])
                dot=np.matmul(q_cryst,np.array([i,j,k]))
                phase=np.exp(2j*np.pi*dot)
                disp=np.real(vec*phase)
                #print('Displacement in',i,j,k,':')
                #print(np.around(disp,decimals=5))
                disp=[ut.cartesian2cryst(d,basis) for d in disp]
                new_pos[:,0]=new_pos[:,0]+i
                new_pos[:,1]=new_pos[:,1]+j
                new_pos[:,2]=new_pos[:,2]+k
                new_pos=new_pos+disp
                try:
                    positions=np.vstack([positions,new_pos])
                except NameError:
                    positions=new_pos
    positions=[ut.cryst2cartesian(p,Pcell) for p in positions]
    distorted=Atoms(symbols=symbols,positions=positions,cell=scell)
    if silent==False:
        cell.get_spacegroup(distorted)
    return distorted

def distort_phonon(q_cryst,freq,results_ph_path,OP=None,dist=1,silent=False):
    """Distort the structure according to given active phonons and get an ase.Atoms superstructure as output.

    In order to point that phonon you need:
    q_cryst = q points you are interested in crystaline units.
    freqs = index of the frequenzies you are interested in.
    results_ph_path = Folder where you ph.x output is stored.

    #VALUES TO DEFINE YOUR ORDER PARAMETER:
    OP = Order Parameter
         Desired linear combination for the condensing modes.
    dist = Amount of distortion in the desired direction.
           Usefull for continuous plots in a single direction.

    silent = No text output

    #NOTES
    The applied distortion is:
    distortion = dist * SUM (direction * qe_polvector)
    """

    #READ STRUCTURE
    if len(np.shape(q_cryst))==1:
        q_cryst=[q_cryst]
        freq=[freq]
        OP=[OP]
    if np.any(OP)==None:
        OP=np.zeros(len(q_cryst))

    #GET FREQS and DISPLACEMENTS
    displacements=[]
    for i,q in enumerate(q_cryst):
        dyn=__find_dyn_file(q,results_ph_path)
       #read the dyn file
        if silent==False:
            print('reading point from',dyn,'...')
        q_alat,basis,atoms,alat,dynmat,atoms_mass=read_dyn_file_q(dyn,q)
        q_freqs,q_displacements=__freq_disp_matdyn(dynmat,atoms_mass)
        if silent==False:
            print('q=',q_alat,'// Frequency =',q_freqs[freq[i]-1],'cm-1')
            print('Displacement vector =')
            print(np.around(q_displacements[freq[i]-1],decimals=6)*dist)
            print()
        #The list of displacements
        displacements=displacements+[q_displacements[freq[i]-1]]
    
    #displacement vector for the unit cell
    vec=[d*dist for d in displacements]

    #READ ORIGINAL CRYTAL
    atoms[1]=[ut.cartesian2cryst(p,basis) for p in atoms[1]] #change to cryst units
    Pcell=basis*alat*cons.au2ang

    #BUILD CONMENSURATE SUPERCELL
    supercell,q_cryst=__generate_supercell(q_cryst,basis,cryst_units=True)
    if silent==False:
        print('Conmensurate supercell:',supercell)
    #GENERATE UNDISTORTED SUPERCELL
    #simbols and supercell lattice
    symbols=np.prod(supercell)*atoms[0]
    scell=np.ones([3,3])
    for i in range(3):
        scell[i]=Pcell[i]*supercell[i]

    #DISTORT THE SUPERSTRUCTURE
    indices=supercell
    #iter withing the different subcells of the supercell (different phases)
    for i in range(indices[0]):
        for j in range(indices[1]):
            for k in range(indices[2]):
                #new set of positions for subcell
                new_pos=np.array(atoms[1])
                new_pos[:,0]=new_pos[:,0]+i
                new_pos[:,1]=new_pos[:,1]+j
                new_pos[:,2]=new_pos[:,2]+k
                #add each of the distortions
                for l,q in enumerate(q_cryst):
                    #Phase factor
                    dot=np.matmul(q,np.array([i,j,k]))
                    phase=np.exp(2j*np.pi*dot)
                    #Add phase to the displacement
                    disp=np.real(OP[l]*vec[l]*phase)
                #print('Displacement in',i,j,k,':')
                #print(np.around(disp,decimals=5))
                    disp=[ut.cartesian2cryst(d,basis) for d in disp]
                    new_pos=new_pos+disp
                try:
                    positions=np.vstack([positions,new_pos])
                except NameError:
                    positions=new_pos
    positions=[ut.cryst2cartesian(p,Pcell) for p in positions]
    distorted=Atoms(symbols=symbols,positions=positions,cell=scell)
    if silent==False:
        cell.get_spacegroup(distorted)
    return distorted

def energy_surface_pwi(q_cryst,freqs,results_ph_path,OP,dest_folder,
                       template,neg_d=-0.025,pos_d=0.025,step=0.0005,symprec=1e-05):
    """Creates the necessary QE inputs to create an energy landscape in the
    direction of a certain order parameter.

    In order to point that phonon you need:

    q_cryst = q points you are interested in crystaline units.
    freqs = index of the frequenzies you are interested in.
    results_ph_path = Folder where you ph.x output is stored.
    OP = Order Parameter
         Desired linear combination for the condensing modes.
    dest_folder = Folder where your inputs will be stored
    template = A template input you want to copy
    neg_d = "minimum" displacement (the most negative)
    pos_d = "maximum" displacement (the most positive)
    step = steps in which you want to increase the displacement
    symprec = precision for the symmetry analysis
    """
    d_values=np.arange(0,neg_d-step,-step)
    d_values=np.hstack([d_values,np.arange(step,pos_d+step,step)])
    d_values=np.sort(d_values)
    os.mkdir(dest_folder)
    print('Creating...')
    for d in d_values:
        struct=distort_phonon(q_cryst,freqs,results_ph_path,OP,dist=d,silent=True)
        SG=cell.get_spacegroup(struct,symprec=symprec,silent=True)
        d=np.around(d,decimals=3)
        line_new = '%7s  %7s  %2s' % ('Disp =',d, SG)
        print(line_new)
        if d>0:
            name=str(d)
        elif d==0:
            name=str(0.0)
        elif d<0:
            name='n'+str(np.abs(d))
        file=dest_folder+'/'+name+'.pwi'
        cell.store_structure_QE_pwi(struct,file,template)


def read_energy_landscape(folder,relative=True):
    """Reads the output of your energy landscape calculations. It expects for the files to be named 0.025.pwo or n0.025.pwo (where n stands for "negative" and the number for the "displacement")
    folder = path to the folder containing the outputs
    relative = If relative is true then the relative energy respect the undistorted is plotted

    Returns an array with two columns where the first one stands for the displacements (the number uppon which you have multiplied the QE "polarization vector" (displacement)) and the second are energies in meV
    output: [displacements, energies (meV)]
    """
    outputs=glob.glob(folder+'/*pwo')
    for out in outputs:
        #get the float of the displacemnt, the "d" by which I am multipling the pol. vector
        disp=out.split('/')[-1]
        disp=disp[:-4]
        if "n" in disp:
            disp=-float(disp[1:])
        else:
            disp=float(disp)

        #get the energy for each scf
        energy=utx.grep_total_energy(out)
        if energy != False:
            try:
                data=np.vstack((data,[disp,energy]))
            except NameError:
                data=np.array([disp,energy])

    if relative==True:
        i=np.where(data[:,0]==0)[0][0]
        data[:,1]=(data[:,1]-data[i,1])*cons.Ry2eV*1000
    else:
        data[:,1]=data[:,1]*cons.Ry2eV*1000
    sorted_data = data[np.argsort(data[:,0])]
    return sorted_data

def plot_energy_landscape(data,results_ph_path=None,q_cryst=None,freq=None,trim_points=None,title=None,markersize=5,relative=True,save_as=None):
    """Plots and energy landscape
    data = Either the folder containing the energy landscape calculations or the already read data
    results_ph_path = Folder where you ph.x output is stored.
    q_cryst = q point you are interested in crystaline units
    freq = index of the frequenzy you are interested in.
    trim_points = Amount of points to be trimmed from the energy landscape data at each of the sides (left,right)
    title = 'THE TITLE'
    relative = If relative is true then the relative energy respect the undistorted is plotted
    save_as = 'name.png' or whatever format

    When results_ph_path, q_cryst and freq are present a secondary axis with the maximum displacement on any atom is ploted
    """
    if type(data)==str:
        data=read_energy_landscape(data,relative=relative)
    if results_ph_path!=None and freq!=None and q_cryst!=None:    # Prepare second x axis
        dyn=__find_dyn_file(q_cryst,results_ph_path)
        #read a displacement vector related to the one we are analyzing (the "modulus" will be the same)
        disp=read_dyn_file(dyn)[4][freq-1]
        largest=0
        for d in disp:               #Find the largest displacement
            norm=np.linalg.norm(d)
            if norm > largest:
                largest=norm
        #create a maximum displacement (in Ang) axis defining the necesary functions
        def d2ang(x):
            return x*largest
        def ang2d(x):
            return x/largest

    #PLOTTING PART
    fig, ax = plt.subplots()
    if trim_points==None:
        ax.plot(data[:,0],data[:,1],".")
    else:
        s=trim_points[0]
        f=len(data[:,0])-trim_points[1]
        ax.plot(data[s:f,0],data[s:f,1],".",markersize=markersize)

    ax.axvline(x=0,linewidth=0.2,color='grey')
    if title!=None:
        plt.title(title)
    ax.set_ylabel("Energy difference (meV)")
    ax.set_xlabel("Order parameter (d)")
    if results_ph_path!=None and freq!=None and q_cryst!=None:    # Prepare second x axis
        secax=ax.secondary_xaxis('top',functions=(d2ang,ang2d))
        secax.set_xlabel('Maximum displacement [Ang]')
    ax.grid()
    plt.tight_layout()
    if save_as!=None:
        plt.savefig(save_as,dpi=300)
    plt.show()

def plot_energy_landscape_compare(data_set,results_ph_path=None,q_cryst=None,freq=None,trim_points=None,title=None,legend=None,markersize=5,relative=True,save_as=None):
    """Compare different energy landscapes in the same plot
    data_set = An array either the folders containing the energy landscapes calculations or the already read data
    results_ph_path = Folder where you ph.x output is stored.
    q_cryst = q point you are interested in crystaline units
    freq = index of the frequenzy you are interested in.
    trim_points = Amount of points to be trimmed from the energy landscape data at each of the sides (left,right)
    title = 'THE TITLE'
    relative = If relative is true then the relative energy respect the undistorted is plotted
    save_as = 'name.png' or whatever format
       
    When results_ph_path, q_cryst and freq are present a secondary axis with the maximum displacement on any atom is ploted
    """
    
    if results_ph_path!=None and freq!=None and q_cryst!=None:    # Prepare second x axis
        dyn=__find_dyn_file(q_cryst,results_ph_path)
        #read a displacement vector related to the one we are analyzing (the "modulus" will be the same)
        disp=read_dyn_file(dyn)[4][freq-1]
        largest=0
        for d in disp:               #Find the largest displacement
            norm=np.linalg.norm(d)
            if norm > largest:
                largest=norm
        #create a maximum displacement (in Ang) axis defining the necesary functions
        def d2ang(x):
            return x*largest
        def ang2d(x):
            return x/largest
            
    #PLOTTING
    fig, ax = plt.subplots()
    for i,data in enumerate(data_set):
        if type(data)==str:
            data=read_energy_landscape(data,relative)
        if trim_points==None:
            ax.plot(data[:,0],data[:,1],".")
        else:
            s=trim_points[0]
            f=len(data[:,0])-trim_points[1]
            ax.plot(data[s:f,0],data[s:f,1],".",markersize=markersize)
    ax.axvline(x=0,linewidth=0.2,color='grey')
    if title!=None:
        plt.title(title)
    ax.set_ylabel("Energy difference (meV)")
    ax.set_xlabel("Order parameter (d)")
    if results_ph_path!=None and freq!=None and q_cryst!=None:    # Prepare second x axis
        secax=ax.secondary_xaxis('top',functions=(d2ang,ang2d))
        secax.set_xlabel('Maximum displacement [Ang]')
    if legend != None:
        ax.legend(legend)
    ax.grid()
    plt.tight_layout()
    if save_as!=None:
        plt.savefig(save_as,dpi=300)
    plt.show()


def poli(x,coef):
    """Generates the y value at the x point for a polinomy defined by certain coeficients
    x = point to evaluate
    coef = coeficients from the highest degree to the lowest (weird)
    """
    y=0
    for deg in range(coef.shape[0]):
        y=y+coef[deg]*x**(coef.shape[0]-1-deg)
    return y

def energy_landscape_fit(data,results_ph_path=None,q_cryst=None,freq=None,poli_order='automatic',title=None,
                         trim_points=None,fit_lim=None,save_as=None,markersize=5):
    """Fit a polinomial to your energy landscape
    data = Either the folder containing the energy landscape calculations or the already read data
    results_ph_path = Folder where you ph.x output is stored.
    q_cryst = q point you are interested in crystaline units
    freq = index of the frequenzy you are interested in.
    poli_order = Order of the polinomy (automatically it will select the highest possible up to 20)
    title = 'THE TITLE'
    trim_points = Amount of points to be trimmed from the energy landscape data at each of the sides (left,right)
    fit_lim = limits in which you want your fit your polinomy (depending on the number of points the order of the polynomia is limited)
    save_as = 'name.png' or whatever format

    When results_ph_path, q_cryst and freq are present:
        - A secondary axis with the maximum displacement on any atom is ploted
        - returns the frozen phonon frequency (cm-1)
    """
    if type(data)==str:
        data=read_energy_landscape(data)

    if results_ph_path!=None and freq!=None and q_cryst!=None:    # Prepare second x axis
        dyn=__find_dyn_file(q_cryst,results_ph_path)
        #read a displacement vector related to the one we are analyzing (the "modulus" will be the same)
        disp=read_dyn_file(dyn)[4][freq-1]
        largest=0
        for d in disp:               #Find the largest displacement
            norm=np.linalg.norm(d)
            if norm > largest:
                largest=norm
        #create a maximum displacement (in Ang) axis defining the necesary functions
        def d2ang(x):
            return x*largest
        def ang2d(x):
            return x/largest

    #Trim data (remove points that you don't want)
    if trim_points!=None:
        s=trim_points[0]
        f=len(data[:,0])-trim_points[1]
        data=data[s:f]

    #generate the polinomial (using the points between the fit_lim)
    if fit_lim==None:
        minl=0
        maxl=len(data[:,0])
    else:
        for i in range(len(data[:,0])):
            if data[i,0]>fit_lim[0]:
                minl=i
                maxl=i
                break
        for i in range(len(data[:,0])):
            if data[i,0]>fit_lim[1]:
                maxl=i
                break
            if maxl==minl:
                maxl=len(data[:,0])
    if poli_order=='automatic':
        poli_order=len(data[minl:maxl,0])-1
        if poli_order>20:
            poli_order=20
    coef=np.polyfit(data[minl:maxl,0],data[minl:maxl,1],poli_order)
    poli_fit = poli(data[:,0],coef)
#    print('The second derivative at zero is',2*coef[-3])

    #PLOTTING
    fig, ax = plt.subplots()
    ax.plot(data[:,0],data[:,1],".")    #scf data
    ax.plot(data[:,0],poli_fit,label="curve fit",linewidth=1)   # polinomial fit data

    ax.axvline(x=0,linewidth=0.2,color='grey')

    # polinomial fit_lim limits
    ax.axvline(data[minl,0],linestyle="--",linewidth=1,color="limegreen")
    ax.axvline(data[maxl-1,0],linestyle="--",linewidth=1,color="limegreen")

    #y limits of the plot
    ymax=max(data[:,1])
    ymin=min(data[:,1])
    interval=ymax-ymin
    ax.set_ylim(ymin-0.05*interval,ymax+0.05*interval)

    if title!=None:
        plt.title(title)
    ax.set_ylabel("Energy difference (meV)")
    ax.set_xlabel("Order parameter (d)")
    if results_ph_path!=None and freq!=None and q_cryst!=None:    # Prepare second x axis
        secax=ax.secondary_xaxis('top',functions=(d2ang,ang2d))
        secax.set_xlabel('Maximum displacement [Ang]')
    #ax.grid()y
    plt.tight_layout()
    if save_as!=None:
        plt.savefig(save_as,dpi=300)
    plt.show()
    if results_ph_path!=None and freq!=None and q_cryst!=None:    # Return frequency eigenvalue in cm-1
        frequency=frozen_phonon_freq(data,results_ph_path,q_cryst,freq,poli_order=poli_order) #data is allready trimed
        return frequency

def frozen_phonon_freq(data,results_ph_path,q_cryst,freq,poli_order='automatic',trim_points=None):
    """Return the frozen phono frequency in (cm-1)
    data = Either the folder containing the energy landscape calculations or the already read data
    results_ph_path = Folder where you ph.x output is stored.
    q_cryst = q point you are interested in crystaline units
    freq = index of the frequenzy you are interested in.
    poli_order = Order of the polinomy (automatically it will select the highest possible up to 20)
    trim_points = Amount of points to be trimmed from the energy landscape data at each of the sides (left,right)

    Returns the frozen phonon frequency (cm-1)
    """
    if type(data)==str:
        data=read_energy_landscape(data)

    #get the QE_norm factor
    file=__find_dyn_file(q_cryst,results_ph_path)
    q_point, basis, positions, alat, QE_dynamical_matrix, atoms_mass=read_dyn_file_q(file,q_cryst)
    freqs,displacements=__freq_disp_matdyn(QE_dynamical_matrix,atoms_mass)
    mass_conv=91.22000/83141.9438563716 #taken from Zr
    norm2=__qe_norm_factor2(displacements[freq-1],atoms_mass)*mass_conv   # in u units

    #Trim data (remove points that you don't want)
    if trim_points!=None:
        s=trim_points[0]
        f=len(data[:,0])-trim_points[1]
        data=data[s:f]

    if poli_order=='automatic':
        poli_order=len(data[:,0])-1
        if poli_order>20:
            poli_order=20

    Norm=np.sqrt(norm2)
    data_q=np.array(data)
    data_q[:,0]=data[:,0]*Norm*alat
    data_q[:,1]=data_q[:,1]/(cons.Ry2eV*1000)
    coef=np.polyfit(data_q[:,0],data_q[:,1],poli_order)
    quadra = coef[coef.shape[0]-3]
    if quadra<0:
        sign=-1
        quadra=-quadra
    else:
        sign=1
    freq=np.sqrt((quadra*2*cons.Ry2jul)/(cons.u2Kg*cons.bohr2metre**2))
    freq=sign*freq*cons.hz2cm/(2*np.pi)
    return freq
