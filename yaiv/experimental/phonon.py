#PYTHON module for analyzing charge density waves and Bohr-Oppenheimer energy surfaces

import numpy as np
import matplotlib.pyplot as plt
import glob
from ase import Atoms
import re
import os
import sys
from math import gcd
import spglib as spg

#import yaiv.transformations as trs
import yaiv.utils as ut
import yaiv.experimental.cell_analyzer as cell
import yaiv.constants as cons


def read_dyn_file(file,qe_format=True):
    """Read the .dyn# file generated by QE and outputs:
    q_point(alat), basis(alat), atomic_positions(alat), frequencies(cm-1), displacements(normalized), alat (au), atomic_masses(2m_e).

    qe_format = Bolean for the displacements output format:
        if True: 
            [[x_1,y_1,z_1],
            [x_2,y_2,z_2],
            ...]
        if False:
            One dimensional array
    return q_point, basis, positions, alat, freqs, displacements, atom_mass"""

    read_qpoint=True
    read_vec=False
    first_vec=True
    atom_types=[]
    freqs=[]
    atom_mass=[]
    dyn_out=open(file,'r')
    for line_n, line in enumerate(dyn_out):
        if line_n==2: # reads atom types and atoms number
            l=line.split()
            num_atoms=int(l[1])
            num_types=int(l[0])
            alat=float(l[3])
        if line_n>2 and line_n in range(7,7+num_types): #read atom types
            l=line.split()
            atom_types=atom_types+[l[1][1:]]
            atom_mass=atom_mass+[float(l[3])]
        if line_n>2 and line_n in range(7+num_types,7+num_types+num_atoms): # read positions
            l=line.split()
            l=[float(i) for i in l]
            pos=np.array(l)
            try:
                positions=np.vstack([positions,pos])
            except NameError:
                positions=pos
        if line_n in [4,5,6]:  #Read basis
            l=line.split()
            b=np.array([float(l[0]),float(l[1]),float(l[2])])
            try:
                basis_vec=np.vstack([basis_vec,b])
            except NameError:
                basis_vec=b
        if re.search('q =',line) and read_qpoint==True:  #Reads q_point
            l=line.split()
            q_point=np.array([float(l[3]),float(l[4]),float(l[5])])
            read_qpoint=False
        if read_vec==True and num<=num_atoms:  #Reads displacements
            l=line.split()
            X=complex(float(l[1]),float(l[2]))
            Y=complex(float(l[3]),float(l[4]))
            Z=complex(float(l[5]),float(l[6]))
            if num==1:
                v=np.array([X,Y,Z])
            else:
                v=np.vstack([v,np.array([X,Y,Z])])
            num=num+1 # counts the number of atoms
            if num>num_atoms:
                read_vec=False
                if first_vec==True:
                    vectors=[v]
                    first_vec=False
                else:
                    vectors=vectors+[v]
        if re.search('freq',line):    #Reads frequencies
            l=line.split()
            f=float(l[7])
            freqs=np.append(freqs,f)
            read_vec=True
            num=1 # counter so that we read num_atoms vectors for each freq
    atoms=[]
    masses=[]
    for p in positions:
        atoms=atoms+[atom_types[int(p[1])-1]]
        masses=masses+[atom_mass[int(p[1])-1]]
    positions=[atoms,positions[:,2:]]
    vectors=np.array(vectors)
    if qe_format==False:
        dim=3*len(positions[0])
        vectors=vectors.reshape(dim,1,dim)
    return q_point,basis_vec,positions,alat,freqs,vectors,masses

def __find_dyn_file(q_cryst,results_ph_path):
    """Finds the QE.dyn* file that holds the q point you are looking for.
    q_cryst = q point you are interested in crystaline units
    results_ph_path = Folder where you ph.x output is stored.
    returns: qe_dyn_file path
    """
    dyn1_file=glob.glob(results_ph_path+'/*dyn1')
    basis=read_dyn_file(dyn1_file[0])[1]
    K_vec=ut.K_basis(basis)

    output=None
    dyn_files=glob.glob(results_ph_path+'/*dyn*')
    #remove matdyn just in case:
    r = list(filter(lambda x: 'results_matdyn' in x, dyn_files))
    if len(r)>0:
        dyn_files.remove(r[0])

    for file in dyn_files:
        lines=open(file,'r')
        for line in lines:
            if re.search('q =',line):
                l=line.split()
                q=[float(l[i]) for i in range(3,6)]
                q_c=ut.cartesian2cryst(q,K_vec)
                deg=ut.__expand_star(q_c)
                for q in deg:
                    diff=q_cryst-q
                    if np.all(np.around(diff,decimals=4)==0):
                        output=file
    if output==None:
        print('ERROR: Point not found in dyn0 file (doesn\'t compute star)')
    return output

def read_dyn_q(q_cryst,results_ph_path,qe_format=True):
    """Read the .dyn# file generated by QE and outputs:
    q_point(alat), basis(alat), atomic_positions(alat), alat(a.u), QE_dynamical matrix, atomic_masses(2m_e).
    INPUT:
    q_cryst = q point you are interested in crystaline units
    results_ph_path = Folder where you ph.x output is stored.
    qe_format = Boolean telling whether you want the dynamical matrix as written by QE (multiplied by masses).
        if False:
            The real dynamical matrix in Ry^2 units is plotted

    notice that:
    q_point = q point you have read in alat units (as QE prints it)
    QE_dynamical matrix is not the true dynamical matrix, instead is what QE print as the dynamical matrix.
    It is multiplied by sqrt(MiMj) where Mi and Mj are the masses of i and j atoms related by the matrix.
    You have to multiply by these masses each (3x3) submatrix in order to diagonalize and get freq^2 (Ry)
    as eigenvalues.

    return: q_point, basis, positions, alat, QE_dynamical_matrix, atom_mass"""

    file=__find_dyn_file(q_cryst,results_ph_path)
    q_point,basis_vec,positions,alat,freqs,vectors,masses = read_dyn_file(file)
    num_atoms=len(positions[0])
    num_types=len(set(positions[0]))

    read_dynmat=False

    dyn_out=open(file,'r')
    for line_n, line in enumerate(dyn_out):
        if re.search('q =',line):
            l=line.split()
            q_point=np.array([float(l[3]),float(l[4]),float(l[5])])
            q_c=ut.cartesian2cryst(q_point,ut.K_basis(basis_vec))
            deg=ut.__expand_star(q_c)
            for q in deg:
                diff=q-q_cryst
                if np.all(np.around(diff,decimals=4)==0):
                    dim=num_atoms*3
                    dyn_mat=np.zeros([dim,dim],dtype=complex)
                    read_dynmat=True
        if read_dynmat==True:
            #read dinamical matrix
            l=line.split()
            if len(l)==2: #block indices
                n=int(l[0])
                m=int(l[1])
                num=0
            elif len(l)==6: #matrix components
                X=complex(float(l[0]),float(l[1]))
                Y=complex(float(l[2]),float(l[3]))
                Z=complex(float(l[4]),float(l[5]))
                row=np.array([X,Y,Z])
                if num==0:
                    sub_mat=row
                    num=1
                else:
                    sub_mat=np.vstack([sub_mat,row])
                    num=num+1
                if num==3:
                    i=(n-1)*3
                    j=(m-1)*3
                    dyn_mat[i:i+3,j:j+3]=sub_mat
            if re.search('Dynamical',line) or re.search('Diagonalizing',line):
                break
    if qe_format==False:
        dyn_mat=__QEdyn2Realdyn(dyn_mat,masses)
    return q_point,basis_vec,positions,alat,dyn_mat,masses

def __QEdyn2Realdyn(dyn_mat,masses):
    """It transforms from the QE dynamical matrix (multiplied by the masses) to the real dynamical matrix in Ry² units.

    dyn_mat = Dynamical matrix as written by QE
    masses = Array of atomic masses as given by QE in the .dyn file

    returns dyn_mat
    """
    dim=len(masses)
    dyn = np.copy(dyn_mat)
    for n in range(dim):
        for m in range(dim):
            i=3*n
            j=3*m
            dyn[i:i+3,j:j+3]=dyn[i:i+3,j:j+3]/np.sqrt(masses[n]*masses[m])
    return dyn

def __pol_matmul(a,b):
    """Dot product between two polarization vectors written as default QE output.
    [[x_1,y_1,z_1],
    [x_2,y_2,z_2],
    ...]
    Used as pol_matmul(vecs[1],vecs[4])"""
    dot=0
    for i in range(len(a)):
        part=np.dot(np.conj(a[i]),b[i])
        dot=dot+part
    return dot


def diago_dyn(dyn_mat,masses,qe_format_in=True,qe_format_out=True):
    """Given the dynamical matrix and masses in QE.dyn units it replicates QE output:
    frequencies (cm-1), displacements(normalized).

    dyn_mat = Dynamical matrix
    masses = atomic masses given in 2*me units (same as QE .dyn output)
    qe_format_in = (Boolean) Whether the input dynamical matrix is as printed by QE, or the real one (in Ry² units).
    qe_format_out = (Boolean) Whether the displacements are written qe_format or as a 1D array.

    return: freqs, displacements"""
    #get the real dinamical matrix mat
    if qe_format_in==True:
        dyn = __QEdyn2Realdyn(dyn_mat,masses)
    eig,pol=np.linalg.eig(dyn)

    #change freqcuencies to (cm-1) and to real
    eig=np.sqrt(eig)*cons.Ry2cm
    for i,v in enumerate(eig):
        if np.around(np.imag(v),decimals=10)==0:
            eig[i]=np.real(v)
        elif np.around(np.real(v),decimals=10)==0:
            eig[i]=-np.abs(np.imag(v))
        else:
            print('Frequency is neither real or imaginary')
            return 'Error: Frequency is neither real or imaginary'
    eig=np.real(eig)

    #go from polarization vectors to normalized displacements
    dim = len(masses)
    eigenvectors=np.array(pol)
    for c in range(len(eigenvectors)):
        for n in range(dim):
            i=3*n
            eigenvectors[i:i+3,c]=eigenvectors[i:i+3,c]/np.sqrt(masses[n])
        eigenvectors[:,c]=eigenvectors[:,c]/np.linalg.norm(eigenvectors[:,c])
    eigenvectors=eigenvectors.transpose()
    pol=pol.transpose()

    #order both displacements and freqs
    freqs=np.array(eig)
    disp=np.array(eigenvectors)
    pol_vec=np.array(pol)
    order=np.argsort(eig)
    for i,n in enumerate(order):
        freqs[i]=eig[n]
        disp[i]=eigenvectors[n]
        pol_vec[i]=pol[n]

    #write displacemnets in QE form:
    if qe_format_out==True:
        disp=disp.reshape(dim*3,dim,3)
    return freqs,disp

def __benchmark_diago(dyn_file,thr_freq=3,thr_vec=4):
    """Given a QE.dyn file it benchmarks the output of QE agains the modules subroutines to read and
    diagonalize the dynamical matrix.
    thr_freq = Up to what decimal to check frequencies.
    thr_vec = Up to what decimal to check vectors.

    Notice that there is a Ry2cm-1 factor involved and that the eigenvectors are well defined up to a
    complex phase. This routine rotates each eigenvector to the same angle as QE in order to compare.

    WARNING = The benchmark will fail for any degenerate modes!!! Any linear combination can be a mode
    """
    print('Frequencies up to',thr_freq,'decimal')
    print('Vectors up to',thr_vec,'decimal')
    print('(Only ouputs when there is a mismatch)')
    print()
    #Read QE ouput directly
    q,basis,positions,alat,qe_freqs,qe_vecs,masses=read_dyn_file(dyn_file)

    #Find q_cryst
    K_vec=ut.K_basis(basis)
    q_cryst=ut.cartesian2cryst(q,K_vec)

    #read the QE "dynamical matrix"
    tmp=dyn_file.split('/')
    path=''
    for word in tmp[:-1]:
        path=path+word+'/'
    q,basis,positions,alat,dynmat,masses=read_dyn_q(q_cryst,path)

    #"diagonalize" the matrix to find displacements and frequencies:
    freqs,vecs=diago_dyn(dynmat,masses)

    #check frequencies
    for i,f in enumerate(freqs):
        diff=freqs[i]-qe_freqs[i]
        if np.around(diff,decimals=thr_freq)!=0:
            print('freqs',freqs[i],qe_freqs[i],'dont past the test.')

    #check polarization vectors
    dim=vecs[0].shape[0]*vecs[0].shape[1]
    for i,vec in enumerate(vecs):
        #reshape
        v=np.reshape(vec,[1,dim])[0]
        qe=np.reshape(qe_vecs[i],[1,dim])[0]
        #find qe_angle
        for c,j in enumerate(qe):
            if np.around(j,decimals=2)!=0:
                angle_v=np.angle(v[c])
                angle_qe=np.angle(qe[c])
                phase=np.exp(1j*(angle_qe-angle_v))
                break
        #rotate my computed vector to align
        for j,elem in enumerate(v):
            v[j]=v[j]*phase
        #check the difference:
        diff1=np.around(v-qe,decimals=thr_vec)
        diff2=np.around(v+qe,decimals=thr_vec)
        if np.any(diff1!=0) and np.any(diff2!=0):
            print('pol vector',i+1,"not correct")
            print(np.around(v,decimals=thr_vec))
            print(np.around(qe,decimals=thr_vec))
    print('Test finished!')


def __benchmark_all(results_ph_path,thr_freq=3,thr_vec=3):
    """Iterates over all the QE.dyn files in order to benchmark them (look __benchmark_diago)
    thr_freq = Up to what decimal to check frequencies.
    thr_vec = Up to what decimal to check vectors.

    WARNING = The benchmark will fail for any degenerate modes!!! Any linear combination can be a mode
    """
    files=glob.glob(results_ph_path+'/*dyn*')
    for file in sorted(files)[1:]:
        print(file)
        __benchmark_diago(file,thr_freq,thr_vec)

def __generate_supercell(q_point,basis_vec,cryst_units=False):
    """Returns the supercell conmensurate with the q_point and the q_point in crystalline units:

    q_point = list of  q points in 2pi/alat as printed by ph.dyn (or cryst units optionally)
    basis_vec = Real space basis vectors in alat as printed by ph.dyn
    cryst_units = Wether the input is in crystal units

    return: supercell, q_cryst"""
    supercell=np.zeros(3)
    if len(np.shape(q_point))==1:
        if cryst_units==False:
            q_cryst=ut.cartesian2cryst(q_point,ut.K_basis(basis_vec))
        else:
            q_cryst=q_point
        for i,k in enumerate(q_cryst):
            for cell in range(1,101):
                phase=cell*k
                if phase%1 == 0:  # If it is an integer
                    supercell[i]=cell
                    break
                if cell==100:
                    print("WARNING!: Conmensurate supercell reached 100 cells in certain direction")
    elif len(np.shape(q_point))==2:
        supercell=np.ones(3).astype(int)
        if cryst_units==False:
            q_cryst=ut.cartesian2cryst(q_point,ut.K_basis(basis_vec),list_of_vec=True)
        else:
            q_cryst=q_point
        for i,vec in enumerate(q_cryst): #For all K-vectors
            p_super=np.zeros(3)     #Partial supercell for each vector
            for j,k in enumerate(vec): #For each component j of every vector(i)
                for cell in range(1,101):
                    phase=cell*k
                    if phase%1 == 0:
                        p_super[j]=cell
                        break
                    if cell==100:
                        print("WARNING!: Conmensurate supercell reached 100 cells in certain direction")
            p_super=np.around(p_super).astype(int)
            for j,num in enumerate(p_super): #Find conmensurate between supercell and p_super
                mcm=supercell[j]*p_super[j]/gcd(supercell[j],p_super[j])
                supercell[j]=mcm
    supercell=supercell.astype(int)
    return supercell,q_cryst

def __grep_displacement_vectors(q_cryst,freq,results_ph_path,silent=True):
    """Grep the displacement vectors from QE from a a list of different (or equivalent) q_points and frequencies.

    q_cryst = q points you are interested in crystaline units.
    freq = index of the frequenzies you are interested in (starting at 1).
    results_ph_path = Folder where you ph.x output is stored.
    silent = No text output

    returns: q_alats, dis_freqs, displacements
    """
    displacements=[]
    q_alats=[]
    dis_freqs=[]
    for i,q in enumerate(q_cryst):
        q_alat,basis,atoms,alat,dynmat,atoms_mass=read_dyn_q(q,results_ph_path)
        q_freqs,q_displacements=diago_dyn(dynmat,atoms_mass)
        if silent==False:
            print('q =',q_alat,'// Frequency =',q_freqs[freq[i]-1],'cm-1')
            print('Displacement vector = ')
            print(np.around(q_displacements[freq[i]-1],decimals=8))
            print()
        #The list of displacements
        displacements=displacements+[q_displacements[freq[i]-1]]
        q_alats=q_alats+[q_alat]
        dis_freqs=dis_freqs+[q_freqs[freq[i]-1]]
    return q_alats, dis_freqs, displacements

def __distort_structure(supercell,Pcell,p_pos,basis,q_cryst,OP,displacements):
    """Distort structure and returns the atomic positions for the distorted one in cartesian units

    supercell = [x,y,z] defining the supercell conmensurate with the distortion.
    Pcell = Primitive cell in anstroms.
    p_pos = Initial atomic positions in the primitive cell in crystal coordinates. 
    basis = In alat units
    q_cryst = the respective q points of each of the displacements
    OP = Order Parameter
         Desired linear combination for the condensing modes.
    displacements =  Displacements to apply in QE_format (as a Nx3 matrix)

    """
    #DISTORT THE SUPERSTRUCTURE
    indices=supercell
    #iter withing the different subcells of the supercell (different phases)
    for i in range(indices[0]):
        for j in range(indices[1]):
            for k in range(indices[2]):
                #new set of positions for subcell
                new_pos=np.array(p_pos)
                new_pos[:,0]=new_pos[:,0]+i
                new_pos[:,1]=new_pos[:,1]+j
                new_pos[:,2]=new_pos[:,2]+k
                #add each of the distortions
                for l,q in enumerate(q_cryst):
                    #Phase factor
                    dot=np.matmul(q,np.array([i,j,k]))
                    phase=np.exp(2j*np.pi*dot)
                    #Add phase to the displacement
                    disp=np.real(OP[l]*displacements[l]*phase)
                    #Pass to crystal units
                    disp=[ut.cartesian2cryst(d,basis) for d in disp]
                    new_pos=new_pos+disp
                try:
                    positions=np.vstack([positions,new_pos])
                except NameError:
                    positions=new_pos
    positions=[ut.cryst2cartesian(p,Pcell) for p in positions]
    return positions

def distort_phonon(q_cryst,results_ph_path,OP=None,freq=None,dist=0.01,silent=False):
    """Distort the structure according to given active phonons and get an ase.Atoms superstructure as output.

    In order to point that phonon you need:
    q_cryst = q points you are interested in crystaline units.
    results_ph_path = Folder where you ph.x output is stored.

    #VALUES TO DEFINE YOUR ORDER PARAMETER:
    OP = Order Parameter
         Desired linear combination for the condensing modes.

    freq = index of the frequenzies you are interested in (starting at 1).
    dist = Amount of distortion in the desired direction.
           Usefull for continuous plots in a single direction.

    silent = No text output

    #NOTES
    The applied distortion is:
    distortion = dist * SUM (direction * qe_polvector)
    """

    #READ STRUCTURE
    if len(np.shape(q_cryst))==1:
        q_cryst=[q_cryst]
        OP=[OP]
    DIM=len(q_cryst)
    if freq==None:
        freq=np.ones(DIM).astype(int)
    elif type(freq)==int:
        freq= [freq]
    if np.any(OP)==None:
        OP=np.ones(DIM)

    #Get alat, structure, masses...
    q_alat,basis,atoms,alat,dynmat,atoms_mass=read_dyn_q(q_cryst[0],results_ph_path)

    if silent==False:
        print('Order parameter =',OP,' // ','Global factor = ', dist, ' // alat =',alat,'(a.u)')
        print()
        print('The general displacement at each config is given by:')
        print('(OP * Global_factor * displacements)*alat')
        print('---------------------------------------------------')

    #GET FREQS and DISPLACEMENTS
    q_alats,dis_freqs,displacements=__grep_displacement_vectors(q_cryst,freq,results_ph_path)
    if silent==False:
        for i,q_alat in enumerate(q_alats):
            print('q=',q_alats[i],'// Frequency =',dis_freqs[i],'cm-1')
            print('Displacement vector (alat) = ',OP[i]*dist, 'x')
            print(np.around(displacements[i],decimals=6))
            print()
    
    #Final displacement vector for the unit cell (still as a list of displacements)
    vec=[d*dist for d in displacements]
    if silent==False:
        final_vec=0
        for i,v in enumerate(vec):
            final_vec=final_vec+OP[i]*v
        print('---------------------------------------------------')
        print('Final applied displacement (Å): (OrderParameter*Global_factor)')
        print(np.around(final_vec*alat*cons.au2ang,decimals=6))

    #Prepare ORIGINAL CRYSTAL
    atoms[1]=[ut.cartesian2cryst(p,basis) for p in atoms[1]] #change to cryst units
    Pcell=basis*alat*cons.au2ang  #primitive cell in angstroms

    #BUILD CONMENSURATE SUPERCELL
    supercell,q_cryst=__generate_supercell(q_cryst,basis,cryst_units=True)
    if silent==False:
        print()
        print('Conmensurate supercell:',supercell)
    #GENERATE UNDISTORTED SUPERCELL
    #simbols and supercell lattice
    symbols=np.prod(supercell)*atoms[0]
    scell=np.ones([3,3])
    for i in range(3):
        scell[i]=Pcell[i]*supercell[i]

    positions=__distort_structure(supercell,Pcell,atoms[1],basis,q_cryst,OP,vec)

    distorted=Atoms(symbols=symbols,positions=positions,cell=scell)
    if silent==False:
        cell.get_spacegroup(distorted)
    return distorted

def __grid_generator(grid,from_zero=False):
    """
    Generate an uniform grid from [-1,1] in any dimensions and returns a list of the points conforming the grid.

    grid = [N1,N2,N3...] describing your grid (between [-1,1])
            If Ni=1 then Xi=1 for all points
    from_zero = (Boolean) Zero won't appear in even grids, if you force it the grid for that dimension
                will be between [0,1].

    returns list_of_points
    """
    #Generate the GRID
    DIM=len(grid)
    temp=[]
    for g in grid:
        if from_zero==True:
            s=0
        elif g==1:
            s=1
        else:
            s=-1
        temp=temp+[np.linspace(s,1,g)]
    res_to_unpack = np.meshgrid(*temp)
    assert(len(res_to_unpack)==DIM)
    
    #Unpack the grid as points
    for x in res_to_unpack:
        c=x.reshape(np.prod(np.shape(x)),1)
        try:
            coords=np.hstack((coords,c))
        except NameError:
            coords=c
    return coords

def CDW_sym_analysis(q_cryst,results_ph_path,freq=None,grid=None,from_zero=False,dist=0.01,symprec=1e-5,silent=True,size=False,OUT=False):
    """Performs a CDW symmetry analysis for a given number of unstable modes. Tries all the possible order parameter combinations
    within a privided grid and outputs the resulting Space Group.

    q_cryst = q points you are interested in crystaline units.
    results_ph_path = Folder where you ph.x output is stored.
    freq = index of the frequenzies you are interested in (starting at 1).
            By default it will take the lowest frequency ones.
    grid = [N1,N2,N3...] describing your grid (between [-1,1])
            By default will be a [2,2,2...] grid
            If Ni=1 then Xi=1 for all points
    from_zero = (Boolean) Zero won't appear in even grids, if you force it the grid for that dimension will be between [0,1].
    dist = Amount of distortion in the desired direction.
           The final distortion will be multiplied by this factor.
    symprec = Symmetry thushold as defined by spglib.
    silent = (Bolean) Minimum text output.
    size = (Bolean) New cell size compared to the original one.
    OUT = (Bolean) If true, instead of printing only returns the Order Parameter and corresponding SpaceGroups and cell sizes.


    return OPs, SGs(, sizes)
    """
    
    #READ STRUCTURE
    if len(np.shape(q_cryst))==1:
        q_cryst=[q_cryst]
    DIM=len(q_cryst)
    if len(np.shape(q_cryst))==1:
        q_cryst=[q_cryst]
    if freq==None:
        freq=np.ones(DIM).astype(int)
    elif type(freq)==int:
        freq= [freq]
    if np.any(grid == None):
        grid=np.ones(DIM).astype(int)*2
        from_zero=True
    elif type(grid)==int:
        grid= [grid]
    elif type(grid)!=list:
        grid=grid.astype(int)
    
    #Get alat, structure, masses...
    q_alat,basis,atoms,alat,dynmat,atoms_mass=read_dyn_q(q_cryst[0],results_ph_path)

    if silent==False:
        print('Order parameter in a',grid,'grid  // ','Global factor = ', dist, ' // alat =',alat,'(a.u)')
        print()
        print('The general displacement at each config is given by:')
        print('(OP * Global_factor * displacements)*alat')
        print('---------------------------------------------------')

    #GET FREQS and DISPLACEMENTS
    q_alats,dis_freqs,displacements=__grep_displacement_vectors(q_cryst,freq,results_ph_path,silent=silent)
    #Final displacement vector for the unit cell (still as a list of displacements)
    vec=[d*dist for d in displacements]

    #Prepare ORIGINAL CRYSTAL
    atoms[1]=[ut.cartesian2cryst(p,basis) for p in atoms[1]] #change to cryst units
    Pcell=basis*alat*cons.au2ang  #primitive cell in angstroms

    supercell,q_cryst=__generate_supercell(q_cryst,basis,cryst_units=True)
    if silent==False:
        print('Conmensurate supercell:',supercell)
        print('---------------------------------------------------')
    
    #GENERATE UNDISTORTED SUPERCELL
    #simbols and supercell lattice
    symbols=np.prod(supercell)*atoms[0]
    scell=np.ones([3,3])
    for i in range(3):
        scell[i]=Pcell[i]*supercell[i]

    #Get OrderParameters within the grid
    OPs=__grid_generator(grid,from_zero=from_zero)

    i_atoms=len(atoms[1])
    SGs=[]
    sizes=[]
    for OP in OPs:
        positions=__distort_structure(supercell,Pcell,atoms[1],basis,q_cryst,OP,vec)
        distorted=Atoms(symbols=symbols,positions=positions,cell=scell)
        SG=cell.get_spacegroup(distorted,symprec=symprec,silent=True)
        if size==True:
            o_atoms=len(spg.find_primitive(cell.ase2spglib(distorted),symprec=symprec)[1])
            s=int(o_atoms/i_atoms)
            sizes=sizes+[s]
        if size==True and OUT==False:
            print(OP,SG,' (x'+str(s)+')')
        elif OUT==False:
            print(OP,SG)
        SGs=SGs+[SG]
    if size==False:
        return OPs, SGs
    else:
        return OPs, SGs, np.array(sizes)


def pp_CDW_sym_analysis(OPs,SGs):
    """It process the output of CDW_sym_analysis returning a reduce list of the distinct possible SpaceGroups, as well
    as a corresponding list with the indices for such items in the OrderParameter list.

    example:
    diff_SGs[i] appears in all OPs[indices[i]]

    return diff_SGs,indices
    """
    diff_SGs=list(set(SGs))
    SGs=np.array(SGs)
    indices=[]
    for SG in diff_SGs:
        ind=np.where(SGs==SG)[0]
        indices=indices+[ind]
    return diff_SGs,indices

def energy_surface_pwi(q_cryst,results_ph_path,dest_folder,template,OP=None,grid=None,freq=None,boundary=0.01,primitive=False,from_zero=False,
                       symprec=1e-5,write=False):
    """Creates the necessary QE inputs to create an energy landscape for any combination of order parameters.
    All the information of the created configurations will be saved into a "surf.txt" file.
    There are two main modes:
        GRIDMODE : It creates an uniform grid in the Order parameter space.
        LINEMODE : It explores a predefined direction in the Order parameter space.
    
    q_cryst = q points you are interested in crystaline units.
    results_ph_path = Folder where you ph.x output is stored.
    dest_folder = Folder where your inputs will be stored.
    template = A template QE input you want to copy to generate your inputs.
    OP = If OP is defined, then LINEMODE is activated and OP defines your direction in the Order Parameter space.
    grid = In GRIDMODE:
            [N1,N2,N3...] describing your grid (between [-1,1])
            By default will be a [2,2,2...] grid
            If Ni=1 then Xi=1 for all points
           In LINEMODE:
            It defines the number of points in your line.
    freq = index of the frequenzies you are interested in (starting at 1).
            By default it will take the lowest frequency ones.
    boundary = In GRIDMODE:
               Amount of distortion in any the desired direction.
               It also supports a LIST input so you define a different value for each grid component.
               The final distortion will be multiplied by this factor.
               In LINEMODE:
               The boundary factors by which you want to multiply your order parameter (OP).
    primitive = (Boolean) Whether you want to resulting structures in primitive cell or in supercell form.
    from_zero = (Boolean) Zero won't appear in even grids, if you force it the grid for that dimension will be between [0,1].
    symprec = Symmetry thushold as defined by spglib.
    write = (Bolean) Whether to write the results in your filesystem. Defaulted to False in order to avoid overwritting a previous configuration.
    """
    #READ STRUCTURE
    if len(np.shape(q_cryst))==1:
        q_cryst=[q_cryst]
    DIM=len(q_cryst)
    if freq==None:
        freq=np.ones(DIM).astype(int)
    elif type(freq)==int:
        freq= [freq]
    if OP != None or DIM==1:
        grid_mode = False
    else:
        grid_mode = True

    if grid_mode == True:
        if np.any(grid == None):
            grid=np.ones(DIM).astype(int)*3
        elif type(grid)==int:
            grid= [grid]
        elif type(grid)!=list:
            grid=grid.astype(int)
    else:
        if OP== None:
            OP=[1]
        if type(boundary)==int or type(boundary)==float:
            boundary=[-boundary,boundary]
        if grid==None:
            grid=51
    if write==True:
        if not os.path.exists(dest_folder):
            os.makedirs(dest_folder)

        file=open(dest_folder+'/surf.txt','w')
        orig_stdout = sys.stdout
        sys.stdout = file

    #Get alat, structure, masses...
    q_alat,basis,atoms,alat,dynmat,atoms_mass=read_dyn_q(q_cryst[0],results_ph_path)

    print('---------------------------------------------------')
    if grid_mode == True:
        print('Order parameter in a',grid,'grid  // ','Global factor = ', boundary, ' // alat =',alat,'(a.u)')
    else:
        print('Order parameter in a',OP,'direction  // ','Global factor = ', boundary, ' // alat =',alat,'(a.u)')
    print()
    print('The general displacement at each config is given by:')
    print('(OP * Global_factor * displacements)*alat')
    if write==True:
        print()
        print('Original Lattice (alat) =')
        print(basis)
        print()
        print('Atomic positions (alat)',atoms[0],'=')
        print(atoms[1])
        print()
        print('Atomic masses (2m_e)',atoms[0],'=')
        print(atoms_mass)
        print()
    print('---------------------------------------------------')
    #GET FREQS and DISPLACEMENTS
    q_alats,dis_freqs,displacements=__grep_displacement_vectors(q_cryst,freq,results_ph_path,silent=False)
    #Final displacement vector for the unit cell (still as a list of displacements)
    if type(boundary)==float or type(boundary)==int:
        vec=[d*boundary for d in displacements]
    elif grid_mode == False:
        vec = displacements
    else:
        vec=[]
        for i,d in enumerate(displacements):
            vec=vec+[d*boundary[i]]
    
    final_vec=0
    if grid_mode == True:
        for i,v in enumerate(vec):
            final_vec=final_vec+v
    else:
        for i,v in enumerate(vec):
            final_vec=final_vec+OP[i]*v
        M=(max(np.abs(boundary[0]),np.abs(boundary[1])))
        final_vec=final_vec*M

    print('---------------------------------------------------')
    if grid_mode == True:
        print('Final applied "maximum" displacement (Å): (Sum[Displacements]*Global_factor) =')
    else:
        print('Final applied "maximum" displacement (Å): (Sum[OP*Displacements]*max(abs(Global_factor))) =')
    print()
    print(np.around(final_vec*alat*cons.au2ang,decimals=5))

    #Prepare ORIGINAL CRYSTAL
    atoms[1]=[ut.cartesian2cryst(p,basis) for p in atoms[1]] #change to cryst units
    Pcell=basis*alat*cons.au2ang  #primitive cell in angstroms

    supercell,q_cryst=__generate_supercell(q_cryst,basis,cryst_units=True)
    print()
    print('Conmensurate supercell:',supercell)
    print('---------------------------------------------------')
    if grid_mode == True:
        print('#DATA (', np.prod(grid),'configs ) // [ID, OP, SG]')
    else:
        print('#DATA (', np.prod(grid),'configs ) // [ID, OP*Glob_factor, SG]')

    #GENERATE UNDISTORTED SUPERCELL
    #simbols and supercell lattice
    symbols=np.prod(supercell)*atoms[0]
    scell=np.ones([3,3])
    for i in range(3):
        scell[i]=Pcell[i]*supercell[i]

    #Get OrderParameters within the grid
    if grid_mode == True:
        OPs=__grid_generator(grid,from_zero=from_zero)
    else:
        factors=np.linspace(boundary[0],boundary[1],grid)
        OPs=np.array([list(OP)]*grid,dtype=float)
        for i,x in enumerate(OPs):
            OPs[i]=OPs[i]*factors[i]

    #Create every configuration
    for i,OP in enumerate(OPs):
        positions=__distort_structure(supercell,Pcell,atoms[1],basis,q_cryst,OP,vec)
        distorted=Atoms(symbols=symbols,positions=positions,cell=scell)
        SG=cell.get_spacegroup(distorted,symprec=symprec,silent=True)
        if primitive==True and write==True:
            distorted=cell.ase2spglib(distorted)
            distorted=spg.find_primitive(distorted,symprec=symprec)
        if write==True:
            cell.store_structure_QE_pwi(distorted,dest_folder+'/'+str(i)+'.pwi',template)
        try:
            OUT=np.vstack((OUT,np.array([i,OP,SG],dtype=object)))
        except NameError:
            OUT=np.array([i,OP,SG],dtype=object)

    #Save the output in the corresponding file (sys.stdout is redefined if write==True)
    np.savetxt(sys.stdout,OUT,fmt=['%-10d','%-50s','%s'])
    if write==True:
        sys.stdout = orig_stdout
        file.close()

def __read_energy_surf_data_txt(file):
    """ Reads the file in which the different OPs (order parameters), the corresponding SpaceGroups, original displacements, global factors, alat(a.u), atomic masses and supercell.

    Essentially all the necesary information to build the configurations.

    In grid mode the general displacement at each config is given by:
        (OP * Global_factor * displacements * phase_factor) * alat
    In line mode the general displacement at each config is given by:
        (OP * displacements * phase_factor) * alat
        The global factor is absorved by OP

    return lattice, atoms, positions, masses, alat, boundary, supercell ,OPs, SGs, displacements
    """
    lines=open(file,'r') 
    DATA=False
    DISP=False
    LAT=False
    ATOMS=False
    MASSES=False
    SGs=[]
    displacements=[]
    for line in lines:
        if re.search('Global factor',line):
            p1,p2,p3=line.split('//')
            boundary=p2.split('=')[1]
            boundary=boundary.split('[')[-1].split(']')[0].split(',')
            boundary=np.array([float(x) for x in boundary])
            alat=float(p3.split()[2])
        elif re.search('Displacement vector',line):
            DISP=True
        elif re.search('Original Lattice',line):
            LAT=True
        elif re.search('Atomic positions',line):
            ATOMS=True
            atoms=line.split('[')[-1].split(']')[0].split(',')
            atoms=[x.split('\'')[1] for x in atoms]
        elif re.search('Atomic masses',line):
            MASSES=True
        elif re.search('supercell',line):
            supercell = np.array([int(x) for x in line.split('[')[1].split(']')[0].split()])
        #READ MASSES
        elif MASSES==True:
            masses=[float(x) for x in line.split('[')[-1].split(']')[0].split(',')]
            MASSES=False
        #READ LATTICE
        elif LAT==True:
            if len(line)>3:
                new=np.array([float(x) for x in line.split('[')[-1].split(']')[0].split()])
                try:
                    lattice=np.vstack((lattice,new))
                except NameError:
                    lattice=new
            else:
                LAT=False
                del new
        #READ ATOMIC POSITIONS
        elif ATOMS==True:
            if len(line)>3:
                new_pos=np.array([float(x) for x in line.split('[')[-1].split(']')[0].split()])
                try:
                    positions=np.vstack((positions,new_pos))
                except NameError:
                    positions=new_pos
            else:
                ATOMS=False
                del new_pos
        #READING DISPERSION DATA
        elif DISP==True:
            if len(line)>3:
                l=[x+'j' for x in (line.split('[')[-1].split(']')[0].split('j'))][:3]
                for i,s in enumerate(l):
                    c=''
                    for j in s.split():
                        c=c+j
                    l[i]=c
                d=np.array([complex(x) for x in l])
                try:
                    new=np.vstack((new,d))
                except NameError:
                    new=d
            else:
                DISP=False
                displacements=displacements+[new]
                del new
        #READ MAIN DATA
        elif DATA==True:
            l=line.split('[')
            i=int(l[0])
            p1,p2=l[1].split(']')
            OP=np.array(p1.split(),dtype=float)
            SG=p2.split()
            SG=SG[0]+' '+SG[1]
            SGs=SGs+[SG]
            try:
                OPs=np.vstack((OPs,OP))
            except NameError:
                OPs=OP
        elif re.search('#DATA',line):
            DATA=True
    lines.close()
    return lattice, atoms, positions, masses, alat, boundary, supercell ,OPs, SGs, displacements

def __qe_norm_factor2(QE_disp,masses):
    """Gets the normalization factor for each QE eigenvalue.
    With the QE dynamical matrix and QE normalized displacements the output of the sandwitch:
    <vector|Dynamical|vector>=N^2 freq^2  (freq in Ry)
    Where N^2 is given by this function using eig=QE_disp
    It has units of mass (the ones of the masses you input)
    """
    atoms=len(masses)
    N=0
    for i in range(atoms):
        N=N+masses[i]*(np.linalg.norm(QE_disp[i]))**2
    return N

def poli(x,coef):
    """Generates the y value at the x point for a polinomy defined by certain coeficients
    x = point to evaluate
    coef = coeficients from the highest degree to the lowest (weird)
    """
    y=0
    for deg in range(coef.shape[0]):
        y=y+coef[deg]*x**(coef.shape[0]-1-deg)
    return y


def read_energy_surf_data(folder,relative=True):
    """Reads the output of your energy landscape calculations. It expects a folder with the surf.txt file created by energy_surface_pwi.

    folder = path to the folder containing the outputs and the surf.txt file.
    relative = If relative is true then the relative energy respect the undistorted is plotted

    The output has all the info from surf.txt and the energies:
    return lattice (alat), atoms, positions(alat), masses(2m_e), alat(au), boundary,supercell, OPs, energies(meV)/cell, SGs, displacements
    """

    # Read the surf.txt file with the info about the configuration
    lattice, atoms, positions, masses, alat, boundary,supercell, OPs, SGs, displacements = __read_energy_surf_data_txt(folder+'/surf.txt')
    m=100
    for i,OP in enumerate(OPs):
        n = np.linalg.norm(OP)
        if n < m:
            m,j=n,i
        e=ut.grep_total_energy(folder+'/'+str(i)+'.pwo',meV=True)
        try:
            energies=np.hstack((energies,e))
        except NameError:
            energies=e
    energies=energies/np.prod(supercell)
    if relative == True:
        energies = energies - energies[j]
    return lattice, atoms, positions, masses, alat, boundary,supercell, OPs, energies, SGs, displacements


def plot_energy_landscape(data,title=None,relative=True,grid=True,color=None,prim_axis='ang',sec_axis=True,axis=None,label=None,save_as=None):
    """Plots the energy landscape data

    data = Either the folder containing the energy landscape calculations or the already read data by read_energy_surf_data
    title = 'Your nice and original title for the plot'
    relative = If relative is true then the relative energy respect the undistorted is plotted
    color = string with the color
    prim_axis = 'ang' or 'd', depending you want it in angstrom or d 'order parameter'
    sec_axis = Whether to add a secondary axis
    grid = (Bolean) It can display an automatic grid in the plot
    axis = Matplotlib axis in which to plot, if no axis is present new figure is created
    label = Label for your plot.
    save_as = 'name.png' or whatever format
    """

    if type(data) == str:
        data=read_energy_surf_data(data,relative=relative)
    lattice, atoms, positions, masses, alat, boundary,supercell, OPs, energies, SGs, displacements = data
    direction = OPs[0]/boundary[0]
    
    if axis == None:
        fig=plt.figure()
        ax = fig.add_subplot(111)
    else:
        ax=axis
        
    #Necessary functions to create a maximum displacement (in Ang) axis
    v=0
    for i,d in enumerate(displacements):
        v=v+d*direction[i]
    norms=[np.linalg.norm(x) for x in v]
    largest=np.max(norms)
    i=np.where(norms==largest)[0][0]
    species=atoms[i]
    largest=largest*alat*cons.au2ang
    def d2ang(x):
        return x*largest
    def ang2d(x):
        return x/largest
        
    X=np.linspace(boundary[0],boundary[1],num=len(OPs))
    if prim_axis=='ang':
        X=X*largest
    ax.plot(X,energies,'.',label=label,color=color)
    
    ax.set_ylabel("energy difference (meV/cell)")
    if prim_axis=='ang':
        ax.set_xlabel(species+' displacement ($\mathrm{\AA}$)')
    else:
        ax.set_xlabel("Order parameter (d)")

    if sec_axis==True:
        if prim_axis=='ang':
            secax=ax.secondary_xaxis('top',functions=(ang2d,d2ang))
            secax.set_xlabel("Order parameter (d)")
        else:
            secax=ax.secondary_xaxis('top',functions=(d2ang,ang2d))
            secax.set_xlabel(species+' displacement ($\mathrm{\AA}$)')
    if grid == True:
        ax.grid()
    if title!=None:                             #Title option
       ax.set_title(title)
    plt.tight_layout()
    if save_as!=None:                             #Saving option
        plt.savefig(save_as, dpi=500)
    if axis == None:
        plt.show()


def energy_landscape_fit(data,title=None,trim_points=None,poli_order='automatic',relative=True,
                         prim_axis='ang',sec_axis=True,grid=True,axis=None,save_as=None):
    """Fit a polinomial to your energy landscape

    data = Either the folder containing the energy landscape calculations or the already read data by read_energy_surf_data
    title = 'Your nice and original title for the plot'
    trim_points = Amount of points to be trimmed from the energy landscape data at each of the sides (left,right)
    poli_order = Order of the polinomy (automatically it will select the highest possible up to 20)
    relative = If relative is true then the relative energy respect the undistorted is plotted
    prim_axis = 'ang' or 'd', depending you want it in angstrom or d 'order parameter'
    sec_axis = Whether to add a secondary axis
    grid = (Bolean) It can display an automatic grid in the plot
    axis = Matplotlib axis in which to plot, if no axis is present new figure is created
    save_as = 'name.png' or whatever format
    """

    if type(data) == str:
        data=read_energy_surf_data(data,relative=relative)
    lattice, atoms, positions, masses, alat, boundary,supercell, OPs, energies, SGs, displacements = data
    direction = OPs[0]/boundary[0]
    
    if axis == None:
        fig=plt.figure()
        ax = fig.add_subplot(111)
    else:
        ax=axis
        
    #create a maximum displacement (in Ang) axis defining the necesary functions
    v=0
    for i,d in enumerate(displacements):
        v=v+d*direction[i]
    norms=[np.linalg.norm(x) for x in v]
    largest=np.max(norms)
    i=np.where(norms==largest)[0][0]
    species=atoms[i]
    largest=largest*alat*cons.au2ang
    def d2ang(x):
        return x*largest
    def ang2d(x):
        return x/largest
    
    X=np.linspace(boundary[0],boundary[1],num=len(OPs))
    if prim_axis=='ang':
        X=X*largest
    #Trim data (remove points that you don't want)
    if trim_points!=None:
        s=trim_points[0]
        f=len(X)-trim_points[1]
        X=X[s:f]
        energies=energies[s:f]

    #generate the polinomial (using the points between the fit_lim)
    if poli_order=='automatic':
        poli_order=len(X)-1
        if poli_order>20:
            poli_order=20
    coef=np.polyfit(X,energies,poli_order)
    Y=np.linspace(X[0],X[-1],1001)
    poli_fit = poli(Y,coef)
    
    #PLOTTING
    ax.plot(X,energies,".",label='DFT points')    #scf data
    ax.plot(Y,poli_fit,linewidth=1,label='Poly fit')   # polinomial fit data
    ax.set_ylabel("Energy difference (meV/cell)")
    if prim_axis=='ang':
        ax.set_xlabel(species+' displacement ($\mathrm{\AA}$)')
    else:
        ax.set_xlabel("Order parameter (d)")

    if sec_axis==True:
        if prim_axis=='ang':
            secax=ax.secondary_xaxis('top',functions=(ang2d,d2ang))
            secax.set_xlabel("Order parameter (d)")
        else:
            secax=ax.secondary_xaxis('top',functions=(d2ang,ang2d))
            secax.set_xlabel(species+' displacement ($\mathrm{\AA}$)')

    if len(displacements)==1:
        frequency=frozen_phonon_freq(data,trim_points=trim_points,poli_order=poli_order)
        ax.text(0.15,0.93, 'Freq = '+str(np.around(frequency,decimals=2))+' $cm^{-1}$',
             size=9, ha="center", va="center",transform=ax.transAxes,horizontalalignment='left',
             bbox=dict(boxstyle="round",ec=(1., 0.5, 0.5),fc=(1., 0.8, 0.8)))
    ax.legend()

    if grid == True:
        ax.grid()
    if title!=None:                             #Title option
        ax.set_title(title)
    plt.tight_layout()
    if save_as!=None:                             #Saving option
        plt.savefig(save_as, dpi=500)
    if axis == None:
        plt.show()


def frozen_phonon_freq(data,trim_points=None,poli_order='automatic'):
    """Return the frozen phonon frequency in (cm-1)

    data = Either the folder containing the energy landscape calculations or the already read data by read_energy_surf_data
    trim_points = Amount of points to be trimmed from the energy landscape data at each of the sides (left,right)
    poli_order = Order of the polinomy (automatically it will select the highest possible up to 20)
    """

    if type(data) == str:
        data=read_energy_surf_data(data,relative=True)
    lattice, atoms, positions, masses, alat, boundary,supercell, OPs, energies, SGs, displacements = data
    direction = OPs[0]/boundary[0]
    if len(displacements) > 1:
        print('More than one eigenvector... Thus not a well defined eigenvector')
    norm2=__qe_norm_factor2(displacements[0],masses)*(2*cons.me/cons.u2Kg) #To au units

    X=np.linspace(boundary[0],boundary[1],num=len(OPs))
    #Trim data (remove points that you don't want)
    if trim_points!=None:
        s=trim_points[0]
        f=len(X)-trim_points[1]
        X=X[s:f]
        energies=energies[s:f]
    
    if poli_order=='automatic':
        poli_order=len(X)-1
        if poli_order>20:
            poli_order=20

    Norm=np.sqrt(norm2)
    X=X*Norm*alat
    energies=energies/(cons.Ry2eV*1000) # Pass to Ry
    coef=np.polyfit(X,energies,poli_order)
    quadra = coef[coef.shape[0]-3]
    if quadra<0:
        sign=-1
        quadra=-quadra
    else:
        sign=1
    freq=np.sqrt((quadra*2*cons.Ry2jul)/(cons.u2Kg*cons.bohr2metre**2))
    freq=sign*freq*cons.hz2cm/(2*np.pi)
    return freq
